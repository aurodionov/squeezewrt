--- a/Makefile
+++ b/Makefile
@@ -9,6 +9,7 @@ OPT_FF      = -DFFMPEG
 OPT_LINKALL = -DLINKALL
 OPT_RESAMPLE= -DRESAMPLE
 OPT_VIS     = -DVISEXPORT
+OPT_IRCTRL  = -DIRCONTROL
 
 SOURCES = \
 	main.c slimproto.c buffer.c stream.c utils.c \
@@ -19,6 +20,7 @@ SOURCES_DSD      = dsd.c dop.c dsd2pcm/d
 SOURCES_FF       = ffmpeg.c
 SOURCES_RESAMPLE = process.c resample.c
 SOURCES_VIS      = output_vis.c
+SOURCES_IRCTRL   = ircontrol.c
 
 LINK_LINUX       = -ldl
 
@@ -43,6 +45,9 @@ endif
 ifneq (,$(findstring $(OPT_VIS), $(CFLAGS)))
 	SOURCES += $(SOURCES_VIS)
 endif
+ifneq (,$(findstring $(OPT_IRCTRL), $(CFLAGS)))
+	SOURCES += $(SOURCES_IRCTRL)
+endif
 
 # add optional link options
 ifneq (,$(findstring $(OPT_LINKALL), $(CFLAGS)))
--- /dev/null
+++ b/ircontrol.c
@@ -0,0 +1,197 @@
+/*
+ * Infrared control for Adrian Smith's Squeezelite
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "squeezelite.h"
+#include "slimproto.h"
+
+#ifdef IRCONTROL
+#include <fcntl.h>
+#include <linux/input.h>
+
+// IR codes from:
+// http://code.ohloh.net/file?fid=y73Id2eFh4oo7LptQHjbISjla0M&cid=bERMVA19j_A&s=&fp=27891&mp=&projSelected=true#L0 static
+
+const struct ircommand_mapping {
+	u32_t slimcmd;
+	const char * descr;
+	u8_t inpcmd;
+} commands[] =
+{
+	{0x7689807f, "Volume Up",	0x73},	//cmd_Vup
+	{0x768900ff, "Volume Down",	0x72},	//cmd_Vdown
+	//{0x768910ef, "Play", 0xA6}, //cmd_play
+	{0x768920df, "Pause", 0xA4}, //Play/Pause
+	{0x768920df, "Pause", 0xA6}, //cmd_pause Stop
+
+	{0x7689c03f, "Rewind", 0xA5}, //Prev track
+	{0x7689a05f, "Forward", 0xA3}, //Next track
+	{0x76898f70, "Power On",	0x02},	//Green
+	{0x76898778, "Power Off",	0x03},	//RED
+	{0,0}
+};
+
+static log_level loglevel;
+static int fd = -1;
+static thread_type thread;
+static bool running = true;
+
+#if WIN
+static void *ircontrol_thread() {
+	HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
+	while (running && (fd != -1))
+	{
+		if (WaitForSingleObject(hStdin, 1111) != WAIT_OBJECT_0)
+		{
+			continue;
+		}
+		wake_controller();
+	}
+
+	return 0;
+}
+#endif 
+
+#if LINUX || OSX || FREEBSD
+static void *ircontrol_thread() {
+	event_handle evt;
+	evt.fd = fd;
+	evt.events = POLLIN;
+	while (running && (fd != -1))
+	{
+		if (poll(&evt, 1, 1111) > 0) {
+			if (evt.revents)
+			{
+				//LOG_INFO("wake");
+				wake_controller();
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
+void ircontrol_init(char * device, log_level level) {
+	loglevel = level;
+
+	if (device == NULL)
+	{
+		return;
+	}
+
+	LOG_INFO("init ircontrol");
+
+	if ((fd = open (device, O_RDONLY | O_NONBLOCK)) == -1)
+	{
+		LOG_INFO ("%s is not a vaild device", device);
+	}
+	else
+	{
+		char devname[256] = "Unknown";
+		ioctl (fd, EVIOCGNAME (sizeof (devname)), devname);
+		LOG_INFO ("Reading From : %s (%s)", device, devname);
+	}
+
+#if LINUX || OSX || FREEBSD
+	pthread_attr_t attr;
+	pthread_attr_init(&attr);
+	pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN + IRCONTROL_THREAD_STACK_SIZE);
+	pthread_create(&thread, &attr, ircontrol_thread, NULL);
+	pthread_attr_destroy(&attr);
+#endif
+
+#if WIN
+	thread = CreateThread(NULL, IRCONTROL_THREAD_STACK_SIZE, (LPTHREAD_START_ROUTINE)&ircontrol_thread, NULL, 0, NULL);
+#endif
+}
+
+bool ircontrol_next_code(struct ircontrol_code * pCode) {
+	static struct input_event iev;
+	static const struct ircommand_mapping * pMap;
+
+	if(fd == -1)
+	{
+		return false;
+	}
+
+	while(read (fd, &iev, sizeof(struct input_event)) == sizeof(struct input_event))
+	{
+		if ((iev.type != EV_KEY) || (iev.value != 1))
+		{
+			//LOG_INFO("??? type = %d, value = %d, code = %d", iev.type, iev.value, iev.code);
+			continue;
+		}
+
+		for (pMap = &commands[0]; pMap->slimcmd != 0; pMap ++)
+		{
+			if (iev.code == pMap->inpcmd)
+			{
+				LOG_INFO("0x%08X '%s'", pMap->slimcmd, pMap->descr);
+				pCode->code = pMap->slimcmd;
+				//pCode->rcv_time = gettime_ms();
+				pCode->rcv_time = iev.time.tv_sec * 1000 + iev.time.tv_usec / 1000;
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+void ircontrol_close(void) {
+	if (fd == -1)
+	{
+		return;
+	}
+
+	LOG_INFO("close ircontrol");
+
+	running = false;
+
+#if LINUX || OSX || FREEBSD
+	pthread_join(thread, NULL);
+#endif
+
+	close(fd);
+}
+
+void ircontrol_list_devices(void)
+{
+	int i;
+	char name[128];
+	int fd;
+
+	for ( i = 0; ; i++)
+	{
+		sprintf(name, "/dev/input/event%i", i);
+
+		fd = open(name, O_RDONLY);
+		if (fd < 0)
+		{
+			break;
+		}
+
+		printf("%s\t", name);
+
+		ioctl(fd, EVIOCGNAME(sizeof(name)), name);
+		printf("%s\n", name);
+
+		close(fd);
+	}
+}
+
+#endif // IRCONTROL
--- a/main.c
+++ b/main.c
@@ -88,6 +88,10 @@ static void usage(const char *argv0) {
 #if LINUX || FREEBSD
 		   "  -z \t\t\tDaemonize\n"
 #endif
+#ifdef IRCONTROL
+		   "  -i <infrared device>\tSpecify infrared control device (in /dev/input)\n"
+		   "  -I \t\t\tList input devices\n"
+#endif
 		   "  -t \t\t\tLicense terms\n"
 		   "\n"
 		   "Build options:"
@@ -137,6 +141,9 @@ static void usage(const char *argv0) {
 #if LINKALL
 		   " LINKALL"
 #endif
+#ifdef IRCONTROL
+		   " IRCONTROL"
+#endif
 		   "\n\n",
 		   argv0);
 }
@@ -200,6 +207,10 @@ int main(int argc, char **argv) {
 	log_level log_stream = lWARN;
 	log_level log_decode = lWARN;
 	log_level log_slimproto = lWARN;
+#ifdef IRCONTROL
+	log_level log_ircontrol = lWARN;
+	char *infrared_control_device = NULL;
+#endif // IRCONTROL
 
 	char *optarg = NULL;
 	int optind = 1;
@@ -217,7 +228,11 @@ int main(int argc, char **argv) {
 
 	while (optind < argc && strlen(argv[optind]) >= 2 && argv[optind][0] == '-') {
 		char *opt = argv[optind] + 1;
-		if (strstr("oabcdefmMnNpPrs", opt) && optind < argc - 1) {
+		if (strstr("oabcdefmMnNpPrs"
+#ifdef IRCONTROL
+						  "i"
+#endif
+						  , opt) && optind < argc - 1) {
 			optarg = argv[optind + 1];
 			optind += 2;
 		} else if (strstr("ltz"
@@ -230,6 +245,9 @@ int main(int argc, char **argv) {
 #if VISEXPORT
 						  "v"
 #endif
+#ifdef IRCONTROL
+						  "I"
+#endif
 						  , opt)) {
 			optarg = NULL;
 			optind += 1;
@@ -259,7 +277,7 @@ int main(int argc, char **argv) {
 		case 'e':
 			exclude_codecs = optarg;
 			break;
-		case 'd':
+		case 'd':
 			{
 				char *l = strtok(optarg, "=");
 				char *v = strtok(NULL, "=");
@@ -359,6 +377,12 @@ int main(int argc, char **argv) {
 			list_devices();
 			exit(0);
 			break;
+#ifdef IRCONTROL
+		case 'I':
+			ircontrol_list_devices();
+			exit(0);
+			break;
+#endif
 #if RESAMPLE
 		case 'u':
 		case 'R':
@@ -387,6 +411,11 @@ int main(int argc, char **argv) {
 			daemonize = true;
 			break;
 #endif
+#ifdef IRCONTROL
+		case 'i':
+			infrared_control_device = optarg;
+			break;
+#endif
 		case 't':
 			license();
 			exit(0);
@@ -482,8 +511,16 @@ int main(int argc, char **argv) {
		exit(1);
	}
 
+#ifdef IRCONTROL
+	ircontrol_init(infrared_control_device, log_ircontrol);
+#endif // IRCONTROL
+
 	slimproto(log_slimproto, server, mac, name, namefile, modelname);
-	
+
+#ifdef IRCONTROL
+	ircontrol_close();
+#endif // IRCONTROL
+
 	decode_close();
 	stream_close();
 
--- a/slimproto.c
+++ b/slimproto.c
@@ -226,6 +226,27 @@ static void sendSETDName(const char *nam
 	send_packet((u8_t *)name, strlen(name) + 1);
 }
 
+#ifdef IRCONTROL
+
+static void sendIR(u32_t code, u32_t rcv_time) {
+	struct IR_packet pkt;
+
+	memset(&pkt, 0, sizeof(pkt));
+	memcpy(&pkt.opcode, "IR  ", 4);
+	pkt.length = htonl(sizeof(pkt) - 8);
+
+	packN(&pkt.time, rcv_time);
+
+	pkt.ir_code_length = 32;
+	packN(&pkt.ir_code, code);
+
+	LOG_INFO("0x%08X", code);
+
+	send_packet((u8_t *)&pkt, sizeof(pkt));
+}
+
+#endif // IRCONTROL
+
 static void process_strm(u8_t *pkt, int len) {
 	struct strm_packet *strm = (struct strm_packet *)pkt;
 
@@ -653,7 +674,7 @@ static void slimproto_run() {
 				}
 			}
 			UNLOCK_D;
-		
+
 			if (_stream_disconnect) stream_disconnect();
 
 			// send packets once locks released as packet sending can block
@@ -667,6 +688,16 @@ static void slimproto_run() {
 			if (_sendSTMn) sendSTAT("STMn", 0);
 			if (_sendRESP) sendRESP(header, header_len);
 			if (_sendMETA) sendMETA(header, header_len);
+
+#ifdef IRCONTROL
+			{
+				struct ircontrol_code ircode;
+				while (ircontrol_next_code(&ircode))
+				{
+					sendIR(ircode.code, ircode.rcv_time);
+				}
+			}
+#endif // IRCONTROL
 		}
 	}
 }
--- a/slimproto.h
+++ b/slimproto.h
@@ -22,6 +22,19 @@
 
 #pragma pack(push, 1)
 
+#ifdef IRCONTROL
+
+struct IR_packet {
+	char  opcode[4];
+	u32_t length;
+	u32_t time;
+	u8_t  code_format;
+	u8_t  ir_code_length;
+	u32_t ir_code;
+};
+
+#endif // IRCONTROL
+
 // from S:N:Slimproto _hello_handler
 struct HELO_packet {
 	char  opcode[4];
--- a/squeezelite.h
+++ b/squeezelite.h
@@ -627,3 +627,21 @@ struct codec *register_vorbis(void);
 struct codec *register_faad(void);
 struct codec *register_dsd(void);
 struct codec *register_ff(const char *codec);
+
+// ircontrol.c
+#ifdef IRCONTROL
+
+#define IRCONTROL_THREAD_STACK_SIZE  (64 * 1024)
+
+struct ircontrol_code
+{
+	u32_t code;
+	u32_t rcv_time;
+};
+
+void ircontrol_list_devices(void);
+void ircontrol_init(char * device, log_level level);
+void ircontrol_close(void);
+bool ircontrol_next_code(struct ircontrol_code * pCode);
+
+#endif // IRCONTROL
